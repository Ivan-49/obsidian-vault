---
tags:
  - assembler
---
## Транслятор
Транслятор ассемблера это программа которая переводит исходный код программы в машинный код.

## Двойной проход
TASM является двухпроходным транслятором по умолчанию.

#### Этапы работы(два прохода)
Проход 1: Сбор таблицы символов
пример:
```assembler
jmp label1 ; label1 = ??? -> в таблицу
mov ax,1   ; 100h: BB 10 00 (placeholder)
label1:    ; label1 = 103h -> записать в таблицу
  ... <какой то код>
```

Цель первого прохода собрать все адреса меток/процедур. Генерирует `.OBJ`.

Проход 2: Подстановка адресов
```

jmp label1 -> EB 02 (103h - 101h = 2)

```

Цель второго прохода заменить placeholders реальными [[Смещения ассемблер|смещениями]] 

---
## проблема forward ссылок при 2 проходах

```
call sub1 ;Проход 1 : думает  =e8 ?? ?? (3 байта)
		; Адрес инструкции: 100h
		
		
		
sub1 PROC FAR; проход 2, нужно far = 9a ?? ?? ?? ?? (5! байт!)


```
про near или far вызовы см тут -> [[near или far вызовы]] 
там же написано как исправить эту ошибку

Структура транслятора TASM - [[Работы транслятора схема.canvas|Схема]]

1. Лексический анализатор (Lexer)
		Разбивает текст на токены
		пример:
``` assembler
mov ax, bx+5    →  [MOV] [AX] [,] [BX] [+] [5]
jmp short label →  [JMP] [SHORT] [LABEL]
call FAR PTR sub→  [CALL] [FAR] [PTR] [SUB]
```

2. Синтаксический анализатор (Parser)
	Строит AST дерево по грамматике
	```
	AST для "mov ax, bx+5":
  MOV
 ├── AX (dest)
 └── ADD
     ├── BX
     └── 5

	```

3. Таблица символов (Symbol Table) - Сердце транслятора
```
┌─────────────┬──────┬──────────┬──────┐
│ Символ      │Тип   │Сегмент   │Адрес │
├─────────────┼──────┼──────────┼──────┤
│ main        │PROC  │CODE      │0100h │
│ sub1        │PROC  │CODE      │????  │ ← Forward!
│ msg         │DB    │DATA      │2000h │
│ @data       │GROUP │DGROUP    │0000h │
└─────────────┴──────┴──────────┴──────┘
```
 она обновляется каждый [[Работа транслятора ассемблер#Двойной проход|проход]] 
 4. 2 Прохода = 2 полных трансляции
 5. **Проход 1: FORWARD ONLY**

text

```
jmp label1           ; label1 → таблица как UNDEFINED 
mov ax, @data        ; @data → HIGH приоритет, известен 
label1:              ; label1 = ТЕКУЩИЙ_АДРЕС → таблица! 
call sub1            ; sub1 → таблица UNDEFINED
```

**НЕ генерирует код** — только таблицу!

## **Проход 2: BACKWARD RESOLUTION**

text

```
jmp label1 → EB 02   ; label1 из таблицы!
call sub1  → 9A....  ; sub1 из таблицы!`
```
## **ПСЕВДОКОД транслятора**

text

```SymbolTable = {}
для каждого прохода в 1..Passes:
     PC = 0  // Program Counter
     для каждой строки в source:
         токены = Lexer(строка)
         AST = Parser(токены)
         
		 если AST.ссылка_на_символ:
			 если символ НЕ в SymbolTable:
				 SymbolTable[символ] = UNDEFINED  // Forward!
		если AST.определение_метки:
			SymbolTable[метка] = PC
		
		PC += размер_инструкции(AST)
		если изменилась таблица:    
		    продолжить проходы
```

## **Почему именно TASM /m5 решает FAR forward?**

text

```
Проход 1: call sub1 → E8 ?? ?? (предполагает NEAR) 
Проход 2: sub1 FAR  → таблица обновлена 
Проход 3: call sub1 → 9A ?? ?? ?? ?? (перегенерировал!) 
Проход 4: адреса стабильны ✓
```

## **Форматы выходных файлов**

text

```
.OBJ (OMF формат):
 ┌──────────────┐ 
 │ Заголовок    │ Программный модуль 
 ├──────────────┤ 
 │ Таблица      │ LINNUM, NAMES, ... 
 │ объектов     │ 
 ├──────────────┤
 │ Сегменты     │ CODE, DATA, STACK
 │ (LEDATA)     │ B8 01 00 EB 02 ... 
 ├──────────────┤ 
 │ Переселенцы  │ "jmp label1 использует символ label1" 
 │ (FIXUPP)     │ 
 └──────────────┘ 
 TLINK читает .OBJ → размещает сегменты → разрешает переселенцы → EXE
```


## **Сравнение трансляторов**

|Ассемблер|Проходы|Forward|FAR|Скорость|
|---|---|---|---|---|
|TASM|2-9|PTR|✓|Средняя|
|MASM|1-∞|Авто|✓|Медленная|
|FASM|**1**|Нет|Нет|Быстрый|
|NASM|1|Нет|Нет|Быстрый|

**TASM уникален**: **универсальный размер инструкций** через PTR + много проходов для сложных forward.